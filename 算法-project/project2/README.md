# Project2 最短路径

##  基本要求

给定图G，在input.txt中给出图的描述，第⼀⾏有两个数字，第⼀个数字表示节点数⽬n，节点标号从0 到n-1，第⼆个表示边的数⽬e，接下来有e⾏，每⾏有三个数字u,v,w，表示边u->v的权值为w。 (1) 给出第1个点到第n个点的最短路径，给出最短路径的⼤⼩和路径，输出到output.txt中。 output.txt最开始有两⾏，第⼀⾏表示最短路径的⻓度，第⼆⾏表示路径的个数(可能不⽌⼀条最短路 径)，接下来每⼀⾏都表示⼀条最短路径(0,n0…,n-1) (2) 对于加权有向图G，如果从顶点s到顶点t的⼀条路径上所有边的权重是严格单调递增或递减的，那么 这条路径称为单调路径，路径中不能出现重复顶点。单调最短路径是单调路径中最短的那条路径。给出 从顶点0到顶点n-1的单调最短路径。

## 注意事项：

1.readfromfile时，是根据空行来判断一个图是否结束，所以input.txt文件每一个图结束后，包括最后一个图，之后都要有一个空行。

2.readfromfile时，是根据每一行","的数量判断行类型的，所以测试时不能用别的分隔符代替。

3.由于没有对main.cpp进行修改，所以output.txt的格式是，先执行run1求每一个图的最短路径，并在每一个图结束后加"end"和空行，之后再执行run2求每一个图的单调最短路径，并在每一个图结束后加"end"和空行。输出格式与给出的标准答案的格式有所不同。

## 需要完善：

1.没有考虑到很多边界情况，比如只有一个节点的图或者没有节点（我觉得应该不会出这种测试样例吧）。

2.求单调最短路径的时候，采用的暴力法求两点之间的所有路径，理论最大时间复杂度可达(n-2)! 且用了递归的方式，对函数调用栈的考验极大。我通过了给出的测试样例，但是没有尝试更大数据，不确定是否面对更复杂的图时是否会出现函数调用栈爆了的情况。

##  参考资料

reference:

1.版权声明：本文为CSDN博主「茄砸」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。

原文链接：https://blog.csdn.net/u013615687/article/details/69062803



2.博客园：Dijkstra算法(二)之 C++详解

原文链接：https://www.cnblogs.com/skywang12345/p/3711514.html



3.简书:DFS求两点间所有路径

原文链接：https://www.jianshu.com/p/8a83aa1c24c5

